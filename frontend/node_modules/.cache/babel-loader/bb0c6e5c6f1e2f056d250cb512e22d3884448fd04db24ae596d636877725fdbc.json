{"ast":null,"code":"/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n\n'use strict';\n\n/**\n * Components\n * @class\n */\nfunction Components() {\n  this.list = {};\n  this.getId = function (node) {\n    return node && node.range.join(':');\n  };\n}\n\n/**\n * Add a node to the components list, or update it if it's already in the list\n *\n * @param {ASTNode} node The AST node being added.\n * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n */\nComponents.prototype.add = function (node, confidence) {\n  const id = this.getId(node);\n  if (this.list[id]) {\n    if (confidence === 0 || this.list[id].confidence === 0) {\n      this.list[id].confidence = 0;\n    } else {\n      this.list[id].confidence = Math.max(this.list[id].confidence, confidence);\n    }\n    return;\n  }\n  this.list[id] = {\n    node: node,\n    confidence: confidence\n  };\n};\n\n/**\n * Find a component in the list using its node\n *\n * @param {ASTNode} node The AST node being searched.\n * @returns {Object} Component object, undefined if the component is not found\n */\nComponents.prototype.get = function (node) {\n  const id = this.getId(node);\n  return this.list[id];\n};\n\n/**\n * Update a component in the list\n *\n * @param {ASTNode} node The AST node being updated.\n * @param {Object} props Additional properties to add to the component.\n */\nComponents.prototype.set = function (node, props) {\n  let currentNode = node;\n  while (currentNode && !this.list[this.getId(currentNode)]) {\n    currentNode = node.parent;\n  }\n  if (!currentNode) {\n    return;\n  }\n  const id = this.getId(currentNode);\n  this.list[id] = {\n    ...this.list[id],\n    ...props\n  };\n};\n\n/**\n * Return the components list\n * Components for which we are not confident are not returned\n *\n * @returns {Object} Components list\n */\nComponents.prototype.all = function () {\n  const list = {};\n  Object.keys(this.list).forEach(i => {\n    if ({}.hasOwnProperty.call(this.list, i) && this.list[i].confidence >= 2) {\n      list[i] = this.list[i];\n    }\n  });\n  return list;\n};\n\n/**\n * Return the length of the components list\n * Components for which we are not confident are not counted\n *\n * @returns {Number} Components list length\n */\nComponents.prototype.length = function () {\n  let length = 0;\n  Object.keys(this.list).forEach(i => {\n    if ({}.hasOwnProperty.call(this.list, i) && this.list[i].confidence >= 2) {\n      length += 1;\n    }\n  });\n  return length;\n};\nfunction componentRule(rule, context) {\n  const sourceCode = context.getSourceCode();\n  const components = new Components();\n\n  // Utilities for component detection\n  const utils = {\n    /**\n     * Check if the node is a React ES5 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES5 component, false if not\n     */\n    isES5Component: function (node) {\n      if (!node.parent) {\n        return false;\n      }\n      return /^(React\\.)?createClass$/.test(sourceCode.getText(node.parent.callee));\n    },\n    /**\n     * Check if the node is a React ES6 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES6 component, false if not\n     */\n    isES6Component: function (node) {\n      if (!node.superClass) {\n        return false;\n      }\n      return /^(React\\.)?(Pure)?Component$/.test(sourceCode.getText(node.superClass));\n    },\n    /**\n     * Check if the node is returning JSX\n     *\n     * @param {ASTNode} node The AST node being checked (must be a ReturnStatement).\n     * @returns {Boolean} True if the node is returning JSX, false if not\n     */\n    isReturningJSX: function (node) {\n      let property;\n      switch (node.type) {\n        case 'ReturnStatement':\n          property = 'argument';\n          break;\n        case 'ArrowFunctionExpression':\n          property = 'body';\n          break;\n        default:\n          return false;\n      }\n      const returnsJSX = node[property] && (node[property].type === 'JSXElement' || node[property].type === 'JSXFragment');\n      const returnsReactCreateElement = node[property] && node[property].callee && node[property].callee.property && node[property].callee.property.name === 'createElement';\n      return Boolean(returnsJSX || returnsReactCreateElement);\n    },\n    /**\n     * Get the parent component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent: function () {\n      return utils.getParentES6Component() || utils.getParentES5Component() || utils.getParentStatelessComponent();\n    },\n    /**\n     * Get the parent ES5 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES5Component: function () {\n      // eslint-disable-next-line react/destructuring-assignment\n      let scope = context.getScope();\n      while (scope) {\n        const node = scope.block && scope.block.parent && scope.block.parent.parent;\n        if (node && utils.isES5Component(node)) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n    /**\n     * Get the parent ES6 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES6Component: function () {\n      let scope = context.getScope();\n      while (scope && scope.type !== 'class') {\n        scope = scope.upper;\n      }\n      const node = scope && scope.block;\n      if (!node || !utils.isES6Component(node)) {\n        return null;\n      }\n      return node;\n    },\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent: function () {\n      // eslint-disable-next-line react/destructuring-assignment\n      let scope = context.getScope();\n      while (scope) {\n        const node = scope.block;\n        // Ignore non functions\n        const isFunction = /Function/.test(node.type);\n        // Ignore classes methods\n        const isNotMethod = !node.parent || node.parent.type !== 'MethodDefinition';\n        // Ignore arguments (callback, etc.)\n        const isNotArgument = !node.parent || node.parent.type !== 'CallExpression';\n        if (isFunction && isNotMethod && isNotArgument) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode} component node, null if we cannot find the component\n     */\n    getRelatedComponent: function (node) {\n      let currentNode = node;\n      let i;\n      let j;\n      let k;\n      let l;\n      // Get the component path\n      const componentPath = [];\n      while (currentNode) {\n        if (currentNode.property && currentNode.property.type === 'Identifier') {\n          componentPath.push(currentNode.property.name);\n        }\n        if (currentNode.object && currentNode.object.type === 'Identifier') {\n          componentPath.push(currentNode.object.name);\n        }\n        currentNode = currentNode.object;\n      }\n      componentPath.reverse();\n\n      // Find the variable in the current scope\n      const variableName = componentPath.shift();\n      if (!variableName) {\n        return null;\n      }\n      let variableInScope;\n      const {\n        variables\n      } = context.getScope();\n      for (i = 0, j = variables.length; i < j; i++) {\n        // eslint-disable-line no-plusplus\n        if (variables[i].name === variableName) {\n          variableInScope = variables[i];\n          break;\n        }\n      }\n      if (!variableInScope) {\n        return null;\n      }\n\n      // Find the variable declaration\n      let defInScope;\n      const {\n        defs\n      } = variableInScope;\n      for (i = 0, j = defs.length; i < j; i++) {\n        // eslint-disable-line no-plusplus\n        if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {\n          defInScope = defs[i];\n          break;\n        }\n      }\n      if (!defInScope) {\n        return null;\n      }\n      currentNode = defInScope.node.init || defInScope.node;\n\n      // Traverse the node properties to the component declaration\n      for (i = 0, j = componentPath.length; i < j; i++) {\n        // eslint-disable-line no-plusplus\n        if (!currentNode.properties) {\n          continue; // eslint-disable-line no-continue\n        }\n\n        for (k = 0, l = currentNode.properties.length; k < l; k++) {\n          // eslint-disable-line no-plusplus, max-len\n          if (currentNode.properties[k].key.name === componentPath[i]) {\n            currentNode = currentNode.properties[k];\n            break;\n          }\n        }\n        if (!currentNode) {\n          return null;\n        }\n        currentNode = currentNode.value;\n      }\n\n      // Return the component\n      return components.get(currentNode);\n    }\n  };\n\n  // Component detection instructions\n  const detectionInstructions = {\n    ClassDeclaration: function (node) {\n      if (!utils.isES6Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n    ClassProperty: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 2);\n    },\n    ObjectExpression: function (node) {\n      if (!utils.isES5Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n    FunctionExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 1);\n    },\n    FunctionDeclaration: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 1);\n    },\n    ArrowFunctionExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      if (node.expression && utils.isReturningJSX(node)) {\n        components.add(node, 2);\n      } else {\n        components.add(node, 1);\n      }\n    },\n    ThisExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node || !/Function/.test(node.type)) {\n        return;\n      }\n      // Ban functions with a ThisExpression\n      components.add(node, 0);\n    },\n    ReturnStatement: function (node) {\n      if (!utils.isReturningJSX(node)) {\n        return;\n      }\n      const parentNode = utils.getParentComponent();\n      if (!parentNode) {\n        return;\n      }\n      components.add(parentNode, 2);\n    }\n  };\n\n  // Update the provided rule instructions to add the component detection\n  const ruleInstructions = rule(context, components, utils);\n  const updatedRuleInstructions = {\n    ...ruleInstructions\n  };\n  Object.keys(detectionInstructions).forEach(instruction => {\n    updatedRuleInstructions[instruction] = node => {\n      detectionInstructions[instruction](node);\n      return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : undefined;\n    };\n  });\n  // Return the updated rule instructions\n  return updatedRuleInstructions;\n}\nComponents.detect = function (rule) {\n  return componentRule.bind(this, rule);\n};\nmodule.exports = Components;","map":{"version":3,"names":["Components","list","getId","node","range","join","prototype","add","confidence","id","Math","max","get","set","props","currentNode","parent","all","Object","keys","forEach","i","hasOwnProperty","call","length","componentRule","rule","context","sourceCode","getSourceCode","components","utils","isES5Component","test","getText","callee","isES6Component","superClass","isReturningJSX","property","type","returnsJSX","returnsReactCreateElement","name","Boolean","getParentComponent","getParentES6Component","getParentES5Component","getParentStatelessComponent","scope","getScope","block","upper","isFunction","isNotMethod","isNotArgument","getRelatedComponent","j","k","l","componentPath","push","object","reverse","variableName","shift","variableInScope","variables","defInScope","defs","init","properties","key","value","detectionInstructions","ClassDeclaration","ClassProperty","ObjectExpression","FunctionExpression","FunctionDeclaration","ArrowFunctionExpression","expression","ThisExpression","ReturnStatement","parentNode","ruleInstructions","updatedRuleInstructions","instruction","undefined","detect","bind","module","exports"],"sources":["/home/adm1/Desktop/react/projects/project_1/frontend/node_modules/eslint-plugin-react-native/lib/util/Components.js"],"sourcesContent":["/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n\n'use strict';\n\n/**\n * Components\n * @class\n */\nfunction Components() {\n  this.list = {};\n  this.getId = function (node) {\n    return node && node.range.join(':');\n  };\n}\n\n/**\n * Add a node to the components list, or update it if it's already in the list\n *\n * @param {ASTNode} node The AST node being added.\n * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n */\nComponents.prototype.add = function (node, confidence) {\n  const id = this.getId(node);\n  if (this.list[id]) {\n    if (confidence === 0 || this.list[id].confidence === 0) {\n      this.list[id].confidence = 0;\n    } else {\n      this.list[id].confidence = Math.max(this.list[id].confidence, confidence);\n    }\n    return;\n  }\n  this.list[id] = {\n    node: node,\n    confidence: confidence,\n  };\n};\n\n/**\n * Find a component in the list using its node\n *\n * @param {ASTNode} node The AST node being searched.\n * @returns {Object} Component object, undefined if the component is not found\n */\nComponents.prototype.get = function (node) {\n  const id = this.getId(node);\n  return this.list[id];\n};\n\n/**\n * Update a component in the list\n *\n * @param {ASTNode} node The AST node being updated.\n * @param {Object} props Additional properties to add to the component.\n */\nComponents.prototype.set = function (node, props) {\n  let currentNode = node;\n  while (currentNode && !this.list[this.getId(currentNode)]) {\n    currentNode = node.parent;\n  }\n  if (!currentNode) {\n    return;\n  }\n  const id = this.getId(currentNode);\n  this.list[id] = { ...this.list[id], ...props };\n};\n\n/**\n * Return the components list\n * Components for which we are not confident are not returned\n *\n * @returns {Object} Components list\n */\nComponents.prototype.all = function () {\n  const list = {};\n  Object.keys(this.list).forEach((i) => {\n    if ({}.hasOwnProperty.call(this.list, i) && this.list[i].confidence >= 2) {\n      list[i] = this.list[i];\n    }\n  });\n  return list;\n};\n\n/**\n * Return the length of the components list\n * Components for which we are not confident are not counted\n *\n * @returns {Number} Components list length\n */\nComponents.prototype.length = function () {\n  let length = 0;\n  Object.keys(this.list).forEach((i) => {\n    if ({}.hasOwnProperty.call(this.list, i) && this.list[i].confidence >= 2) {\n      length += 1;\n    }\n  });\n  return length;\n};\n\nfunction componentRule(rule, context) {\n  const sourceCode = context.getSourceCode();\n  const components = new Components();\n\n  // Utilities for component detection\n  const utils = {\n\n    /**\n     * Check if the node is a React ES5 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES5 component, false if not\n     */\n    isES5Component: function (node) {\n      if (!node.parent) {\n        return false;\n      }\n      return /^(React\\.)?createClass$/.test(sourceCode.getText(node.parent.callee));\n    },\n\n    /**\n     * Check if the node is a React ES6 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES6 component, false if not\n     */\n    isES6Component: function (node) {\n      if (!node.superClass) {\n        return false;\n      }\n      return /^(React\\.)?(Pure)?Component$/.test(sourceCode.getText(node.superClass));\n    },\n\n    /**\n     * Check if the node is returning JSX\n     *\n     * @param {ASTNode} node The AST node being checked (must be a ReturnStatement).\n     * @returns {Boolean} True if the node is returning JSX, false if not\n     */\n    isReturningJSX: function (node) {\n      let property;\n      switch (node.type) {\n        case 'ReturnStatement':\n          property = 'argument';\n          break;\n        case 'ArrowFunctionExpression':\n          property = 'body';\n          break;\n        default:\n          return false;\n      }\n\n      const returnsJSX = node[property]\n        && (node[property].type === 'JSXElement' || node[property].type === 'JSXFragment');\n      const returnsReactCreateElement = node[property]\n        && node[property].callee\n        && node[property].callee.property\n        && node[property].callee.property.name === 'createElement';\n      return Boolean(returnsJSX || returnsReactCreateElement);\n    },\n\n    /**\n     * Get the parent component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent: function () {\n      return (\n        utils.getParentES6Component()\n        || utils.getParentES5Component()\n        || utils.getParentStatelessComponent()\n      );\n    },\n\n    /**\n     * Get the parent ES5 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES5Component: function () {\n      // eslint-disable-next-line react/destructuring-assignment\n      let scope = context.getScope();\n      while (scope) {\n        const node = scope.block && scope.block.parent && scope.block.parent.parent;\n        if (node && utils.isES5Component(node)) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the parent ES6 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES6Component: function () {\n      let scope = context.getScope();\n      while (scope && scope.type !== 'class') {\n        scope = scope.upper;\n      }\n      const node = scope && scope.block;\n      if (!node || !utils.isES6Component(node)) {\n        return null;\n      }\n      return node;\n    },\n\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent: function () {\n      // eslint-disable-next-line react/destructuring-assignment\n      let scope = context.getScope();\n      while (scope) {\n        const node = scope.block;\n        // Ignore non functions\n        const isFunction = /Function/.test(node.type);\n        // Ignore classes methods\n        const isNotMethod = !node.parent || node.parent.type !== 'MethodDefinition';\n        // Ignore arguments (callback, etc.)\n        const isNotArgument = !node.parent || node.parent.type !== 'CallExpression';\n        if (isFunction && isNotMethod && isNotArgument) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode} component node, null if we cannot find the component\n     */\n    getRelatedComponent: function (node) {\n      let currentNode = node;\n      let i;\n      let j;\n      let k;\n      let l;\n      // Get the component path\n      const componentPath = [];\n      while (currentNode) {\n        if (currentNode.property && currentNode.property.type === 'Identifier') {\n          componentPath.push(currentNode.property.name);\n        }\n        if (currentNode.object && currentNode.object.type === 'Identifier') {\n          componentPath.push(currentNode.object.name);\n        }\n        currentNode = currentNode.object;\n      }\n      componentPath.reverse();\n\n      // Find the variable in the current scope\n      const variableName = componentPath.shift();\n      if (!variableName) {\n        return null;\n      }\n      let variableInScope;\n      const { variables } = context.getScope();\n      for (i = 0, j = variables.length; i < j; i++) { // eslint-disable-line no-plusplus\n        if (variables[i].name === variableName) {\n          variableInScope = variables[i];\n          break;\n        }\n      }\n      if (!variableInScope) {\n        return null;\n      }\n\n      // Find the variable declaration\n      let defInScope;\n      const { defs } = variableInScope;\n      for (i = 0, j = defs.length; i < j; i++) { // eslint-disable-line no-plusplus\n        if (\n          defs[i].type === 'ClassName'\n          || defs[i].type === 'FunctionName'\n          || defs[i].type === 'Variable'\n        ) {\n          defInScope = defs[i];\n          break;\n        }\n      }\n      if (!defInScope) {\n        return null;\n      }\n      currentNode = defInScope.node.init || defInScope.node;\n\n      // Traverse the node properties to the component declaration\n      for (i = 0, j = componentPath.length; i < j; i++) { // eslint-disable-line no-plusplus\n        if (!currentNode.properties) {\n          continue; // eslint-disable-line no-continue\n        }\n        for (k = 0, l = currentNode.properties.length; k < l; k++) { // eslint-disable-line no-plusplus, max-len\n          if (currentNode.properties[k].key.name === componentPath[i]) {\n            currentNode = currentNode.properties[k];\n            break;\n          }\n        }\n        if (!currentNode) {\n          return null;\n        }\n        currentNode = currentNode.value;\n      }\n\n      // Return the component\n      return components.get(currentNode);\n    },\n  };\n\n  // Component detection instructions\n  const detectionInstructions = {\n    ClassDeclaration: function (node) {\n      if (!utils.isES6Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ClassProperty: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ObjectExpression: function (node) {\n      if (!utils.isES5Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    FunctionExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 1);\n    },\n\n    FunctionDeclaration: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 1);\n    },\n\n    ArrowFunctionExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      if (node.expression && utils.isReturningJSX(node)) {\n        components.add(node, 2);\n      } else {\n        components.add(node, 1);\n      }\n    },\n\n    ThisExpression: function () {\n      const node = utils.getParentComponent();\n      if (!node || !/Function/.test(node.type)) {\n        return;\n      }\n      // Ban functions with a ThisExpression\n      components.add(node, 0);\n    },\n\n    ReturnStatement: function (node) {\n      if (!utils.isReturningJSX(node)) {\n        return;\n      }\n      const parentNode = utils.getParentComponent();\n      if (!parentNode) {\n        return;\n      }\n      components.add(parentNode, 2);\n    },\n  };\n\n  // Update the provided rule instructions to add the component detection\n  const ruleInstructions = rule(context, components, utils);\n  const updatedRuleInstructions = { ...ruleInstructions };\n  Object.keys(detectionInstructions).forEach((instruction) => {\n    updatedRuleInstructions[instruction] = (node) => {\n      detectionInstructions[instruction](node);\n      return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : undefined;\n    };\n  });\n  // Return the updated rule instructions\n  return updatedRuleInstructions;\n}\n\nComponents.detect = function (rule) {\n  return componentRule.bind(this, rule);\n};\n\nmodule.exports = Components;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}